# string-stroki

String-строки
Мы с вами уже познакомились с символами в уроке про типы данных. Как в обычной жизни, одиночные символы соединяются в слова и строки - это текст, заключённый в двойные кавычки: "Hello, World!". У нас есть два набора инструментов для работы с ними:

Статические строки - они же массивы символов char, являются стандартными для языка C/C++ и работают одинаково на любой платформе. О них поговорим в следующем уроке.
Динамические String-строки, в Arduino за них отвечает отдельная библиотека, которая входит в состав "ядра". Эти строки просты и удобны в использовании, поэтому сначала разберём работу с ними.
Базовый синтаксис
Создание String
Остальные методы
Рассмотрим все библиотечные методы для работы со строками, они применяются к строке через точку. В рассмотренных ниже примерах "тестовая" строка называется myString. Также оставлю некоторые комментарии по оптимизации.

Примечание: большинство функций будут некорректно работать со строками, содержащими символы не из таблицы ASCII (английские буквы + цифры + символы). То есть строки с кириллицей, иероглифами и прочим будут обрабатываться некорректно.
charAt()
myString.charAt(index) - возвращает элемент строки myString под номером index. Аналог - myString[index]; - лучше использовать его вместо charAt()!
setCharAt()
myString.setCharAt(index, val) - записывает в строку myString символ val на позицию index. Аналог - myString[index] = val; - лучше использовать его вместо setCharAt()!
compareTo()
myString.compareTo(myString2)

Возвращает отрицательное число, если myString идёт до myString2
Возвращает положительное число, если myString идёт после myString2
Возвращает 0, если строки одинаковы
concat()
myString.concat(value) - присоединяет value к строке (value может иметь любой численный тип данных). Возвращает true при успешном выполнении, false при ошибке. Аналог - сложение, myString + value;
endsWith()
myString.endsWith(myString2) - проверяет, заканчивается ли myString строкой myString2. В случае совпадения возвращает true
startsWith()
myString.startsWith(myString2) - проверяет, начинается ли myString строкой myString2. В случае совпадения возвращает true
equals()
myString.equals(myString2) - возвращает true, если myString совпадает с myString2. Регистр букв важен
equalsIgnoreCase()
myString.equalsIgnoreCase(myString2) - возвращает true, если myString совпадает с myString2. Регистр букв неважен
indexOf()
myString.indexOf(val) и myString.indexOf(val, from) - ищет и возвращает номер (индекс) значения val в строке. Ищет слева направо, возвращает номер первого символа в совпадении. val может быть char или String, то есть ищем в строке другую строку или символ. Можно искать, начиная с позиции from. В случае, когда не может найти val в строке, возвращает -1.
lastIndexOf()
myString.lastIndexOf(val) и myString.lastIndexOf(val, from) - ищет и возвращает номер (индекс) значения val в строке. Ищет справа налево, возвращает номер последнего символа в совпадении. val может быть char или String, то есть ищем в строке другую строку или символ. Можно искать, начиная с позиции from. В случае, когда не может найти val в строке, возвращает -1.
length()
myString.length() - возвращает длину строки в количестве символов
remove()
myString.remove(index) и myString.remove(index, count) - удаляет из строки символы, начиная с index и до конца, либо до указанного count
replace()
myString.replace(substring1, substring2) - в строке myString заменяет последовательность символов substring1 на substring2.

String myString = "lol kek 4eburek";
// заменить чебурек на пельмень
myString.replace("4eburek", "pelmen");
reserve()
myString.reserve(size) - зарезервировать в памяти количество байт size для работы со строкой
c_str()
myString.c_str() - возвращает указатель char* на строку
trim()
myString.trim() - удаляет пробелы из начала и конца строки. Действует со строкой, к которой применяется
substring()
myString.substring(from) и myString.substring(from, to) - возвращает подстроку, содержащуюся в myString с позиции from и до конца, либо до позиции to

String myString = "lol kek 4eburek";
String chebur = myString.substring(8);
// строка chebur содержит в себе "4eburek"
toCharArray()
myString.toCharArray(buf, len) - записывает строку в массив - буфер buf (типа char []) с начала и до длины len. Автоматически добавляет символ конца строки. В большинстве случаев лучше воспользоваться вариантом c_str()
getBytes()
myString.getBytes(buf, len) - копирует указанное количество символов len в буфер buf (byte []). Автоматически добавляет символ конца строки.
toFloat()
myString.toFloat() - конвертирует и возвращает содержимое строки в тип данных float
toDouble()
myString.toDouble() - конвертирует и возвращает содержимое строки в тип данных double
toInt()
myString.toInt() - конвертирует и возвращает содержимое строки в тип данных int

String myString = "10500";
int val = myString.toInt();
// val теперь 10500
toLowerCase()
myString.toLowerCase() - переводит все символы в нижний регистр. Было ААААА - станет ааааа
toUpperCase()

Проблемы и оптимизация String
Преимущество стрингов заключается в том, что с ними очень легко и удобно работать: собирать из других строк и переменных любых типов, складывать между собой, делить на подстроки и так далее. За удобство приходится платить: String является динамическим объектом (читай урок про динамическую память), что влечёт за собой некоторые проблемы. Также на форумах часто критикуют String и предлагают использовать вместо них обычные си-строки, давайте рассмотрим всё вместе:

String - тяжёлый. Несомненно - использование String-строк сразу добавляет пару килобайт Flash памяти к весу программы, так как для работы с ними используется менеджер памяти (встроенная библиотека). В то же время, если в программе уже используется динамическое выделение памяти - добавление String будет заметно не так сильно. На этом данная проблема заканчивается, потому что если открыть реализацию библиотеки String, то можно увидеть, что все действия со строками выполняются при помощи стандартных строковых функций языка Си (подробнее - в следующем уроке).
String - медленный. Да, когда строка меняет свою длину - она начинает менять свой размер и даже место в оперативной памяти микроконтроллера. Переписывание и перераспределение памяти происходит отнюдь не мгновенно, поэтому операции со String выполняются относительно долго: сотни микросекунд. Если собирать строку посимвольно - каждая прибавка будет выполняться дольше, чем хотелось бы! Этого можно избежать, используя метод reserve(), который зарезервирует память, чтобы увеличение строки происходило без выделения памяти (подробнее об этом ниже). Если место под строку зарезервировано - операции со строкой будут выполняться с такой же скоростью, как и с обычными строками, потому что для них используются те же стандартные строковые функции.
String - опасный. Всё верно, неаккуратная работа со String может привести к сильной фрагментации памяти, неправильной работе программы и даже полному её зависанию. В то же время, если понимать как работают стринги и использовать эффективные и безопасные конструкции в работе с ними - можно избежать абсолютно всех проблем!
Использование памяти
Несмотря на то, что строка - это динамический инструмент, в реализации Arduino она может только увеличиваться. Это означает, что если у нас была длинная строка, а затем мы её обнулили - места в памяти она не стала занимать меньше! То есть
